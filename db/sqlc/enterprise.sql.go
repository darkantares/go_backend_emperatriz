// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: enterprise.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createEnterprise = `-- name: CreateEnterprise :one
INSERT INTO "enterprise" (
  "title", 
  "phone", 
  "email", 
  "contact", 
  "contact_phone", 
  "files", 
  "address", 
  "web", 
  "is_authenticated",
  "status",
  "removable",
  "editable",
  "is_visible",
  "default",
  "created_at", 
  "created_by"
)
VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, now(), $15
)
RETURNING id, title, phone, email, contact, contact_phone, files, address, web, is_authenticated, status, removable, editable, is_visible, "default", created_at, updated_at, deleted_at, created_by, updated_by, deleted_by
`

type CreateEnterpriseParams struct {
	Title           string      `json:"title"`
	Phone           string      `json:"phone"`
	Email           string      `json:"email"`
	Contact         string      `json:"contact"`
	ContactPhone    string      `json:"contact_phone"`
	Files           string      `json:"files"`
	Address         string      `json:"address"`
	Web             string      `json:"web"`
	IsAuthenticated bool        `json:"is_authenticated"`
	Status          bool        `json:"status"`
	Removable       bool        `json:"removable"`
	Editable        bool        `json:"editable"`
	IsVisible       bool        `json:"is_visible"`
	Default         bool        `json:"default"`
	CreatedBy       pgtype.Int4 `json:"created_by"`
}

func (q *Queries) CreateEnterprise(ctx context.Context, arg CreateEnterpriseParams) (Enterprise, error) {
	row := q.db.QueryRow(ctx, createEnterprise,
		arg.Title,
		arg.Phone,
		arg.Email,
		arg.Contact,
		arg.ContactPhone,
		arg.Files,
		arg.Address,
		arg.Web,
		arg.IsAuthenticated,
		arg.Status,
		arg.Removable,
		arg.Editable,
		arg.IsVisible,
		arg.Default,
		arg.CreatedBy,
	)
	var i Enterprise
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Phone,
		&i.Email,
		&i.Contact,
		&i.ContactPhone,
		&i.Files,
		&i.Address,
		&i.Web,
		&i.IsAuthenticated,
		&i.Status,
		&i.Removable,
		&i.Editable,
		&i.IsVisible,
		&i.Default,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.DeletedBy,
	)
	return i, err
}

const deleteEnterprise = `-- name: DeleteEnterprise :one
UPDATE "enterprise"
SET 
  "status" = false,
  "deleted_at" = now(),
  "deleted_by" = $1
WHERE 
  "id" = $2
RETURNING id, title, phone, email, contact, contact_phone, files, address, web, is_authenticated, status, removable, editable, is_visible, "default", created_at, updated_at, deleted_at, created_by, updated_by, deleted_by
`

type DeleteEnterpriseParams struct {
	DeletedBy pgtype.Int4 `json:"deleted_by"`
	ID        int32       `json:"id"`
}

func (q *Queries) DeleteEnterprise(ctx context.Context, arg DeleteEnterpriseParams) (Enterprise, error) {
	row := q.db.QueryRow(ctx, deleteEnterprise, arg.DeletedBy, arg.ID)
	var i Enterprise
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Phone,
		&i.Email,
		&i.Contact,
		&i.ContactPhone,
		&i.Files,
		&i.Address,
		&i.Web,
		&i.IsAuthenticated,
		&i.Status,
		&i.Removable,
		&i.Editable,
		&i.IsVisible,
		&i.Default,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.DeletedBy,
	)
	return i, err
}

const getEnterprise = `-- name: GetEnterprise :one
SELECT id, title, phone, email, contact, contact_phone, files, address, web, is_authenticated, status, removable, editable, is_visible, "default", created_at, updated_at, deleted_at, created_by, updated_by, deleted_by 
FROM "enterprise"
WHERE "id" = $1
`

func (q *Queries) GetEnterprise(ctx context.Context, id int32) (Enterprise, error) {
	row := q.db.QueryRow(ctx, getEnterprise, id)
	var i Enterprise
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Phone,
		&i.Email,
		&i.Contact,
		&i.ContactPhone,
		&i.Files,
		&i.Address,
		&i.Web,
		&i.IsAuthenticated,
		&i.Status,
		&i.Removable,
		&i.Editable,
		&i.IsVisible,
		&i.Default,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.DeletedBy,
	)
	return i, err
}

const listEnterprises = `-- name: ListEnterprises :many
SELECT id, title, phone, email, contact, contact_phone, files, address, web, is_authenticated, status, removable, editable, is_visible, "default", created_at, updated_at, deleted_at, created_by, updated_by, deleted_by FROM "enterprise"
`

func (q *Queries) ListEnterprises(ctx context.Context) ([]Enterprise, error) {
	rows, err := q.db.Query(ctx, listEnterprises)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Enterprise{}
	for rows.Next() {
		var i Enterprise
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Phone,
			&i.Email,
			&i.Contact,
			&i.ContactPhone,
			&i.Files,
			&i.Address,
			&i.Web,
			&i.IsAuthenticated,
			&i.Status,
			&i.Removable,
			&i.Editable,
			&i.IsVisible,
			&i.Default,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.CreatedBy,
			&i.UpdatedBy,
			&i.DeletedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateEnterprise = `-- name: UpdateEnterprise :one
UPDATE "enterprise"
SET 
  "title" = COALESCE($1, "title"),
  "phone" = COALESCE($2, "phone"),
  "email" = COALESCE($3, "email"),
  "contact" = COALESCE($4, "contact"),
  "contact_phone" = COALESCE($5, "contact_phone"),
  "files" = COALESCE($6, "files"),
  "address" = COALESCE($7, "address"),
  "web" = COALESCE($8, "web"),
  "is_authenticated" = COALESCE($9, "is_authenticated"),
  "status" = COALESCE($10, "status"),
  "removable" = COALESCE($11, "removable"),
  "editable" = COALESCE($12, "editable"),
  "is_visible" = COALESCE($13, "is_visible"),
  "default" = COALESCE($14, "default"),
  "updated_at" = now(),
  "updated_by" = COALESCE($15, "updated_by")
WHERE 
  "id" = $16
RETURNING id, title, phone, email, contact, contact_phone, files, address, web, is_authenticated, status, removable, editable, is_visible, "default", created_at, updated_at, deleted_at, created_by, updated_by, deleted_by
`

type UpdateEnterpriseParams struct {
	Title           string      `json:"title"`
	Phone           string      `json:"phone"`
	Email           string      `json:"email"`
	Contact         string      `json:"contact"`
	ContactPhone    string      `json:"contact_phone"`
	Files           string      `json:"files"`
	Address         string      `json:"address"`
	Web             string      `json:"web"`
	IsAuthenticated bool        `json:"is_authenticated"`
	Status          bool        `json:"status"`
	Removable       bool        `json:"removable"`
	Editable        bool        `json:"editable"`
	IsVisible       bool        `json:"is_visible"`
	Default         bool        `json:"default"`
	UpdatedBy       pgtype.Int4 `json:"updated_by"`
	ID              int32       `json:"id"`
}

func (q *Queries) UpdateEnterprise(ctx context.Context, arg UpdateEnterpriseParams) (Enterprise, error) {
	row := q.db.QueryRow(ctx, updateEnterprise,
		arg.Title,
		arg.Phone,
		arg.Email,
		arg.Contact,
		arg.ContactPhone,
		arg.Files,
		arg.Address,
		arg.Web,
		arg.IsAuthenticated,
		arg.Status,
		arg.Removable,
		arg.Editable,
		arg.IsVisible,
		arg.Default,
		arg.UpdatedBy,
		arg.ID,
	)
	var i Enterprise
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Phone,
		&i.Email,
		&i.Contact,
		&i.ContactPhone,
		&i.Files,
		&i.Address,
		&i.Web,
		&i.IsAuthenticated,
		&i.Status,
		&i.Removable,
		&i.Editable,
		&i.IsVisible,
		&i.Default,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.CreatedBy,
		&i.UpdatedBy,
		&i.DeletedBy,
	)
	return i, err
}
